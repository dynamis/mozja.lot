<?xml version="1.0" encoding="UTF-8"?>
<project name="errorcheck" default="" basedir=".">
<description>errorcheck targets</description>
<property name="buildfile.errorcheck.loaded" value="true"/>


<target name="errorcheck" depends="syntaxcheck, placeholdercheck, pluralcheck, wordcheck, suspectedwordcheck, charcheck"/>


<macrodef name="errorlog">
	<attribute name="file"/>
	<attribute name="message"	default=""/>
	<attribute name="append"	default="false"/>
	<attribute name="encoding"	default="UTF-8"/>
	<attribute name="type"		default="error"/>
	<attribute name="fail"		default="false"/>
	<text name="text" optional="true"/>
	<sequential>
		<groovy>
			<arg value="@{file}"/>
			ant.mkdir(dir:new File(args[0]).getParent())
		</groovy>
		<echo taskname="@{taskname}" file="@{file}" message="@{message}@{text}"/>
		<if>
			<istrue value="@{fail}"/>
			<then>
				<fail taskname="@{type}" message="@{message}@{text}"/>
			</then>
			<else>
				<echo taskname="@{type}" message="@{message}@{text}"/>
			</else>
		</if>
	</sequential>
</macrodef>


<!-- * Syntax Check * -->
<target name="syntaxcheck" depends="load-conf" unless="nosyntaxcheck"
	description="syntax error check of converted files">
	<fail message="${cmsg.noprop.syntaxcheck.src.dir}" unless="syntaxcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.syntaxcheck\."/>
	<fail message="${vmsg.syntaxcheck.no.srcdir}">
		<condition><not><available file="${syntaxcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<property name="syntaxcheck.output"  value="temp/syntaxerror.txt"/>
	<delete file="${syntaxcheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		errormsg = new StringBuilder()
		def syntaxchecker(file, encoding, validpattern) {
			content = new StringBuilder()
			file.getFile().getText(encoding).eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
			content = content.toString().replaceAll(validpattern, '')
			if (content) errormsg << "Syntax Error Found in $file:\n$content\n\n"
		}
		
		ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.properties').each {
			syntaxchecker(it, 'UTF-8', /${properties.'RE.properties.validline'}\n/)
		}
		ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.dtd').each {
			syntaxchecker(it, 'UTF-8', /${properties.'RE.dtd.validblock'}\n/)
		}
		// need to support *.ini, *.inc files too...
		//ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.ini').each {
		//	syntaxchecker(it, 'UTF-8', /${properties.'RE.ini.validblock'}\n/)
		//}
		//ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.inc').each {
		//	syntaxchecker(it, 'UTF-8', /${properties.'RE.inc.validblock'}\n/)
		//}
		
		if (errormsg) {
			ant.errorlog(type: 'syntaxerror', file: properties.'syntaxcheck.output', fail: true,
				message: "$errormsg${properties.'vmsg.syntaxcheck.found'}")
		}
	]]></groovy>
</target>

<!-- * Placeholder Check * -->
<target name="placeholdercheck" depends="load-conf" unless="noplaceholdercheck"
	description="placeholder usage error check of converted properties files">
	<fail message="${cmsg.noprop.placeholdercheck.src.dir}" unless="placeholdercheck.src.dir"/>
	<loadmessage pattern="^vmsg\.placeholdercheck\."/>
	<fail message="${vmsg.placeholdercheck.no.srcdir}">
		<condition><not><available file="${placeholdercheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<property name="placeholdercheck.output"  value="temp/placeholdererror.txt"/>
	<delete file="${placeholdercheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		max = 5
		errormsg = new StringBuilder()
		ant.fileset(dir: properties.'placeholdercheck.src.dir', includes:'**/*.properties').each {
			errorlines = new StringBuilder()
			it.getFile().getText('UTF-8').eachLine { line, n ->
				err = false
				(2..max).each { i -> // search %2$2, %3$S...
					if (!err && line =~ "^[^#].+=.+%$i\\\$S") {
						(1..<i).each { j -> // confirm if smaller number placeholders are defined
							err = err || (!line.contains("%$j\$S") && !line.contains("%$j\$0.S"))
						}
					}
				}
				if (err) errorlines << "@line ${n+1}: $line\n"
			}
			if (errorlines) errormsg << "Placeholder Error Found in $it:\n$errorlines\n\n"
		}
		if (errormsg) {
			ant.errorlog(type: 'placeholdererror', file: properties.'placeholdercheck.output', fail: true,
				message: "$errormsg${properties.'vmsg.placeholdercheck.found'}")
		}
	]]></groovy>
</target>

<!-- * Plural Form Usage Check * -->
<target name="pluralcheck" depends="load-conf" unless="nopluralcheck"
	description="plural form error check of converted properties files">
	<loadmessage pattern="^vmsg\.pluralcheck\."/>
	<property name="pluralcheck.output"	value="temp/pluralcheck.txt"/>
	<delete file="${pluralcheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		errormsg = new StringBuilder()
		ant.fileset(dir: properties.'pluralcheck.src.dir', includes:'**/*.properties').each {
			errorlines = new StringBuilder()
			it.getFile().getText('UTF-8').replaceAll(/(?ms)${properties.'pluralcheck.allow'}/, properties.'pluralcheck.allow.replace').eachLine { line, n ->
				if (line =~ /^\s*[-0-9a-zA-Z_.?{@}]+\s*=.+;.+/) {
					errorlines << "@line ${n+1}: $line\n"
				}
			}
			if (errorlines) errormsg << "Plural Form Error Found in $it:\n$errorlines\n\n"
		}
		if (errormsg) {
			ant.errorlog(type: 'pluralformerror', file: properties.'pluralcheck.output',
				message: "$errormsg${properties.'vmsg.pluralcheck.found'}")
		}
	]]></groovy>
</target>


<!-- * Contents (Word/Character) Check * -->
<macrodef name="wordchecksuite">
	<attribute name="allowpattern"	default="${wordcheck.allow}"/>
	<attribute name="denypattern"	default="${wordcheck.deny}"/>
	<attribute name="replacement"	default="${wordcheck.deny.replace}"/>
	<attribute name="dir"			default="${wordcheck.src.dir}"/>
	<attribute name="output"		default="${wordcheck.output}"/>
	<attribute name="excludes"		default=""/>
	<attribute name="regexpengine"	default=""/>
	<sequential>
		<groovy>
			<!-- pass attributes using args to avoid being interprited as groovy code -->
			<arg value="(?m)@{allowpattern}"/>
			<arg value="(?m)@{denypattern}"/>
			<arg value="@{replacement}"/>
			<arg value="@{dir}"/>
			<arg value="@{output}"/>
			<arg value="@{excludes}"/>
			<arg value="@{regexpengine}"/>
			<![CDATA[
			import org.apache.oro.text.regex.*;
			allowpattern	= args[0]
			denypattern		= args[1]
			denypattern_	= ~denypattern
			replacement		= args[2]
			dir				= args[3]
			output			= args[4]
			excludes		= args[5]
			regexpengine	= args[6]
			xmlcommentpattern  = /${properties.'RE.xml.comment'}/
			linecommentpattern = /(?m)^(@line [0-9]+: )?\s*#[^\n]*/
			errormsg           = new StringBuilder()
			def wordchecker(file, encoding, allowpattern, denypattern, commentpattern) {
				errorlines = new StringBuilder()
				content = new StringBuilder()
				file.getFile().getText(encoding).eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
				if (commentpattern) {
					content = content.toString().replaceAll(commentpattern, '')
				}
				if (allowpattern) {
					content = content.toString().replaceAll(allowpattern, properties.'wordcheck.allow.replace')
				}
				
				if (regexpengine == 'jakartaoro') {
					PatternMatcher matcher = new Perl5Matcher();
					PatternCompiler compiler = new Perl5Compiler();
					Pattern pattern = compiler.compile("($denypattern)");
					content.eachLine { line, n ->
						if (matcher.contains(line, pattern)) {
							errorlines << Util.substitute(matcher, pattern, new Perl5Substitution(replacement, Perl5Substitution.INTERPOLATE_ALL), line, Util.SUBSTITUTE_ALL) + "\n"
						}
					}
				}
				else {
					content.eachLine { line, n ->
						if (line =~ denypattern_) {
							errorlines << line.toString().replaceAll("($denypattern)", replacement) + "\n"
						}
					}
				}
				if (errorlines) errormsg << "Error Found in $file:\n$errorlines\n\n"
			}
			
			ant.fileset(dir:dir, includes:'**/*.dtd, ${xmlfiles}', excludes:excludes).each {
				wordchecker(it, 'UTF-8', allowpattern, denypattern, xmlcommentpattern)
			}
			if (properties.'wordcheck.unescape.properties') {
				// note: native2ascii task require JDK installed and JAVA_HOME env set properly, or you'll see the error "error starting Sun's native2ascii"
				ant.native2ascii(src:dir, includes:'**/*.properties',
					dest:'${lot.temp.dir}/wordcheck', reverse:true, encoding:'UTF-8')
				ant.fileset(dir: '${lot.temp.dir}/wordcheck', includes:'**/*.properties', excludes:excludes).each {
					wordchecker(it, 'UTF-8', allowpattern, denypattern, linecommentpattern)
				}
				ant.delete(dir:'${lot.temp.dir}/wordcheck', failonerror:false)
			}
			else {
				ant.fileset(dir:dir, includes:'**/*.properties', excludes:excludes).each {
					wordchecker(it, 'UTF-8', allowpattern, denypattern, linecommentpattern)
				}
			}
			ant.fileset(dir:dir, includes:'**/*.inc, **/unix/*.it', excludes:excludes).each {
				wordchecker(it, 'UTF-8', allowpattern, denypattern, null)
			}
			ant.fileset(dir:dir, includes:'${sjisfiles}', excludes:excludes).each {
				wordchecker(it, 'Shift_JIS', allowpattern, denypattern, null)
			}
			if (errormsg) new File(output).append(errormsg)
		]]></groovy>
	</sequential>
</macrodef>

<target name="wordcheck" depends="load-conf" unless="nowordcheck"
	description="word error check of converted files">
	<fail message="${cmsg.noprop.wordcheck.src.dir}" unless="wordcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.wordcheck\."/>
	<fail message="${vmsg.wordcheck.no.srcdir}">
		<condition><not><available file="${wordcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	<property name="wordcheck.output"  value="temp/worderror.txt"/>
	<delete file="${wordcheck.output}" failonerror="false"/>
	
	<equals property="wordcheck.deny"	value="@{2}|${wordcheck.deny.common}|${wordcheck.deny.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.deny"	value="@{2}|${wordcheck.deny.common}|${wordcheck.deny.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	<property name="wordcheck.deny"		value="${wordcheck.deny.common}"/>
	<equals property="wordcheck.allow"	value="${wordcheck.allow.common}|${wordcheck.allow.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.allow"	value="${wordcheck.allow.common}|${wordcheck.allow.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	<property name="wordcheck.allow"	value="${wordcheck.allow.common}"/>
	
	<wordchecksuite excludes="browser/, calendar/, editor/, mail/, mobile/, suite/"/>
	<wordchecksuite dir="${wordcheck.src.dir}/browser"
		denypattern="${wordcheck.deny}|${wordcheck.deny.firefox}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/calendar"
		denypattern="${wordcheck.deny}|${wordcheck.deny.sunbird}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/editor"
		denypattern="${wordcheck.deny}|${wordcheck.deny.thunderbird}|${wordcheck.deny.seamonkey}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/mail"
		denypattern="${wordcheck.deny}|${wordcheck.deny.thunderbird}|${wordcheck.deny.seamonkey}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/mobile"
		denypattern="${wordcheck.deny}|${wordcheck.deny.fennec}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/suite"
		denypattern="${wordcheck.deny}|${wordcheck.deny.seamonkey}"/>
	
	<loadfile property="wordcheck.error" srcfile="${wordcheck.output}" encoding="UTF-8"
		failonerror="false" quiet="true"/>
	<fail message="${N}${wordcheck.error}${vmsg.wordcheck.found}" if="wordcheck.error"/>
</target>

<target name="suspectedwordcheck" depends="load-conf" unless="nosuspectedwordcheck" if="dosuspectedwordcheck">
	<delete file="${wordcheck.suspected.output}" failonerror="false"/>
	
	<equals property="wordcheck.suspected"	value="@{2}|${wordcheck.suspected.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.suspected"	value="@{2}|${wordcheck.suspected.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	
	<wordchecksuite dir="${wordcheck.src.dir}" output="${wordcheck.suspected.output}"
		allowpattern="##NOTHING##" denypattern="${wordcheck.suspected}"/>
</target>

<target name="charcheck" depends="load-conf" unless="nocharcheck"
	description="character error check of converted files">
	<delete file="${charcheck.output}" failonerror="false"/>
	
	<fail message="${cmsg.noprop.charcheck.src.dir}" unless="charcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.charcheck\."/>
	<fail message="${vmsg.charcheck.no.srcdir}">
		<condition><not><available file="${charcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<wordchecksuite dir="${charcheck.src.dir}" output="${charcheck.output}" excludes="${charcheck.excludes}"
		allowpattern="${charcheck.allow}" denypattern="${charcheck.deny}" replacement="${charcheck.deny.replace}"
		regexpengine="jakartaoro"/>
	
	<loadfile property="charcheck.error" srcfile="${charcheck.output}" encoding="UTF-8"
		failonerror="false" quiet="true"/>
	<fail if="charcheck.error">${N}${charcheck.error}${vmsg.charcheck.found}{$}使用不可と検出された文字のリストを取得したい場合は次の(一行の)コマンドを実行してください:${N}cat ${charcheck.output} | perl -pe 'use utf8; use encoding ("utf-8"); s/^[^\[\]]*(\[CHARERROR\[([^\]]+)\]CHARERROR\])?[^\[\]]*|[^\[\]]*|^Error.+/$1\n/g; s/CHARERROR|[\[\]\s]//g; s/(.)/$1\n/g;' | sort | uniq</fail>
</target>


<!-- * compare/diff/merge locales * -->
<macrodef name="compare">
	<!-- mode = compare, merge (insert+clean), resetorder, resetcomment, resetaccesskey -->
	<attribute name="mode"				default="compare"/>
	<attribute name="locale1"			default="en-US"/>
	<attribute name="locale2"			default="ja"/>
	<attribute name="dir1"				default="${lot.l10n.dir}/@{locale1}"/>
	<attribute name="dir2"				default="${lot.l10n.dir}/@{locale2}"/>
	<attribute name="excludes"			default=""/>
	<attribute name="output"			default="${compare.output}"/>
	<attribute name="format"			default="text"/>
	<attribute name="failonerror"		default="false"/>
	<sequential>
	<groovy taskname="compare" src="compare.groovy">
		<!-- pass attributes using args to avoid being interprited as groovy code -->
		<arg value="@{mode}"/>
		<arg value="@{locale1}"/>
		<arg value="@{locale2}"/>
		<arg value="@{dir1}"/>
		<arg value="@{dir2}"/>
		<arg value="@{excludes}"/>
		<arg value="@{output}"/>
		<arg value="@{format}"/>
		<arg value="@{failonerror}"/>
	</groovy>
	</sequential>
</macrodef>

<target name="compare" depends="load-conf" unless="nocompare"
	description="compare l10n files and check new/obsolate files/entities etc">
	<compare locale2="${locale}" dir2="${compare.dir}" excludes="${compare.excludes}" failonerror="false"/>
</target>
<target name="merge" depends="load-conf" unless="nomerge"
	description="compare l10n files and merge new/obsolate files/entities">
	<confirm message="${lot.l10n.dir}/en-US ディレクトリのファイルと ${merge.dir} ディレクトリのファイルを比較し、新しいファイルやエンティティを追加、古いものは削除します。実行してもよろしいですか？ (Y/N)${N}次のファイルやディレクトリは除外されます: ${merge.excludes}${N}注: 古いものを削除せず残したい場合は merge ではなく insertnew ターゲットを使用してください。"/>
	<compare locale2="${locale}" dir2="${merge.dir}" excludes="${merge.excludes}"
		mode="merge" output="${merge.output}" failonerror="true"/>
	<echo message="ブロック最初のエンティティが削除される場合、ブロックに対するコメントがそのエンティティ単体のものとして削除されることがあります(現時点での仕様)。必ず処理結果を差分ファイルで確認し、必要に応じて修正してください。"/>
</target>
<target name="insertnew" depends="load-conf" unless="nomerge"
	description="compare l10n files and merge new files/entities (not remove obsolate ones)">
	<confirm message="${lot.l10n.dir}/en-US ディレクトリのファイルを ${merge.dir} ディレクトリのファイルを比較し、新しいファイルやエンティティを追加します。実行してもよろしいですか？ (Y/N)${N}次のファイルやディレクトリは除外されます: ${merge.excludes}"/>
	<compare locale2="${locale}" dir2="${merge.dir}" excludes="${merge.excludes}"
		mode="insert" output="${merge.output}" failonerror="true"/>
</target>
<target name="resetaccesskey" depends="load-conf" unless="nomerge"
	description="compare l10n files and reset accesskeys">
	<confirm message="${lot.l10n.dir}/en-US ディレクトリと ${merge.dir} ディレクトリのファイルのアクセスキーを比較し、異なるものは前者の定義に書き換えます。実行してもよろしいですか？ (Y/N)${N}次のファイルやディレクトリは除外されます: ${resetaccesskey.excludes}"/>
	<compare locale2="${locale}" dir2="${resetaccesskey.dir}" excludes="${resetaccesskey.excludes}"
		mode="resetaccesskey" output="${resetaccesskey.output}" failonerror="true"/>
</target>

</project>
