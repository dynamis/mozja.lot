<?xml version="1.0" encoding="UTF-8"?>
<project name="aux" default="" basedir=".">
<description>auxiliary targets</description>
<property name="buildfile.aux.loaded" value="true"/>


<!-- * update and commit lot itself * -->
<target name="checkout-src" depends="load-mainconf"
	description="checkout src files from l10n svn server">
	<exec executable="svn" taskname="svn">
		<!-- svn+ssh://svn.mozilla.l10n.jp/usr/local/var/svn/l10n/trunk/ -->
		<arg line="checkout http://svn.mozilla.l10n.jp/trunk/ ${lot.src.dir}/l10n"/>
	</exec>
</target>
<target name="update-src" depends="load-mainconf"
	description="update src files in the working directory">
	<exec executable="svn" taskname="svn">
		<arg line="update ${lot.src.dir}/l10n"/>
	</exec>
</target>
<target name="update-lot" depends="load-mainconf"
	description="replace current lot with checkouted lot (src/l10n/lot)">
	<confirm message="現在使用中の Localization Tools を L10N SVN の最新バージョンで置き換えます。本当に置き換えてよろしいですか？(Y/N)"
		failmessage="Localization Tools の 置き換えを中止しました"/>
	<property name="update-lot.dir" value="${lot.src.dir}/l10n/lot"/>
	<exec executable="svn" taskname="svn">
		<arg line="update ${update-lot.dir}"/>
	</exec>
	<copy todir="." preservelastmodified="true" overwrite="true">
		<fileset dir="${update-lot.dir}" defaultexcludes="yes"
			includes="${backuplot.includes}" excludes="${backuplot.excludes}"/>
	</copy>
</target>
<target name="update" depends="update-src, update-lot"
	description="update src and lot itself from svn server"/>

<target name="pre-commit-lot" depends="load-mainconf"
	description="copy current lot to svn working directory (src/l10n/lot)">
	<copy todir="${lot.src.dir}/l10n/lot" preservelastmodified="true">
		<fileset dir="." defaultexcludes="no"
			includes="${backuplot.includes}" excludes="${backuplot.excludes}"/>
	</copy>
</target>
<target name="commit-lot" depends="pre-commit-lot"
	description="commit current lot to l10n svn server">
	<property name="commit-lot.dir" value="${lot.src.dir}/l10n/lot"/>
	<input message="コミットログを入力してください:"
		addproperty="commit-lot.message" defaultvalue=""/>
	<fail message="コミットログが指定されていません。">
		<condition><equals arg1="${commit-lot.message}" arg2="" trim="true"/></condition>
	</fail>
	<confirm message='${commit-lot.dir} ディレクトリで次の cvs commit コマンドを実行しようとしています:${N}
		svn commit -m "${commit-lot.message}"${N}本当に実行してもよろしいですか？(Y/N)'
		failmessage="svn commit を中止しました。"/>
	<exec executable="svn" taskname="svn" dir="${commit-lot.dir}">
		<arg line='commit -m "${commit-lot.message}"'/>
	</exec>
</target>



<!-- * backup and restore * -->
<target name="backupsrc" depends="load-mainconf" unless="nobackup"
	description="backup whole src files">
	<mkdir dir="${backupsrc.dir}"/>
	<zip destfile="${backupsrc.file}">
		<zipfileset dir="." defaultexcludes="no"
			includes="${backupsrc.includes}" excludes="${backupsrc.excludes}"/>
	</zip>
</target>

<target name="restoresrc" depends="load-mainconf" unless="norestore"
	description="restore whole src files">
	<loadmessage pattern="^vmsg\.restoresrc\."/>
	<fail message="${vmsg.restoresrc.notfound}">
		<condition><not><available file="${restoresrc.file}" type="file"/></not></condition>
	</fail>
	<confirm message="${vmsg.restoresrc.confirm}" failmessage="${cmsg.restoresrc.cancelled}"/>
	
	<condition property="nobackup">
		<not><available file="${lot.src.dir}" type="dir"/></not>
	</condition>
	<antcall target="backupsrc"/>
	
	<unzip src="${restoresrc.file}" dest="${lot.temp.dir}/restore"/>
	<delete dir="${lot.src.dir}/"/>
	<move todir="${lot.src.dir}">
		<fileset dir="${lot.temp.dir}/restore/${lot.src.dir}"/>
	</move>
</target>

<target name="backuplot" depends="load-mainconf" unless="nobackup"
	description="zip localization tools">
	<mkdir dir="${backuplot.dir}"/>
	<zip destfile="${backuplot.file}">
		<zipfileset dir="." defaultexcludes="no"
			includes="${backuplot.includes}" excludes="${backuplot.excludes}"/>
	</zip>
</target>

<target name="backup" depends="load-mainconf" unless="nobackup"
	description="zip localization tools with src files">
	<mkdir dir="${backup.dir}"/>
	<zip destfile="${backup.file}">
		<zipfileset dir="." defaultexcludes="no"
			includes="${backup.includes}" excludes="${backup.excludes}"/>
	</zip>
</target>


<!-- * error check * -->
<macrodef name="compare-locales">
	<attribute name="locale1"			default="en-US"/>
	<attribute name="locale2"			default="ja"/>
	<attribute name="dir1"				default="${lot.l10n.dir}/@{locale1}"/>
	<attribute name="dir2"				default="${lot.l10n.dir}/@{locale2}"/>
	<attribute name="excludes"			default=""/>
	<attribute name="failonerror"		default="false"/>
	<attribute name="insertnew"			default="false"/>
	<attribute name="removeobsolate"	default="false"/>
	<attribute name="resetcomment"		default="false"/>
	<attribute name="resetaccesskey"	default="false"/>
	<sequential>
	<groovy taskname="compare-locales"><![CDATA[
		locale1     = '@{locale1}'
		locale2     = '@{locale2}'
		dir1        = new File('@{dir1}').getCanonicalPath()
		dir2        = new File('@{dir2}').getCanonicalPath()
		excludes    = '@{excludes}'
		failonerror = '@{failonerror}' == 'true'
		propertiespattern  = /(?m)${properties.'RE.properties.entityblock'}/
		dtdpattern         = /(?m)${properties.'RE.dtd.entityblock'}/
		//l10n[basedir][filekey][entitykey] = [prespace:, precomment:, definition:, key:, value:, postcomment:]
		l10n = [(dir1): [:], (dir2): [:]]
		infomsg      = new StringBuilder()
		fileerrmsg   = new StringBuilder()
		entityerrmsg = new StringBuilder()
		accesskeymsg = new StringBuilder()
		commonkeys = uniquekeys1 = uniquekeys2 = 0
		
		def parse(dir, file, encoding, entityblockpattern, preprocess, postprocess) {
			filekey  = file.toString().replaceAll("$dir/","").replaceAll("/$locale1|$locale2","/*")
			l10n[dir][filekey] = [:]
			content = file.getFile().getText(encoding)
			if (preprocess) content = preprocess(content)
			content.eachMatch(entityblockpattern) {
				block, prespace, precomment, definition, key, value, postcomment ->
				l10n[dir][filekey][key] = [prespace:prespace, precomment:precomment, definition:definition, key:key, value:value, postcomment:postcomment]
				if (postprocess) l10n[dir][filekey][key] = postprocess(l10n[dir][filekey][key])
			}
		}
		
		// Phase 1: Parse L10N Files
		ant.fileset(dir: "$dir1", includes:'**/*.properties', excludes:excludes).each {
			parse(dir1, it, 'UTF-8', propertiespattern, null, null)
		}
		ant.fileset(dir: "$dir2", includes:'**/*.properties', excludes:excludes).each {
			parse(dir2, it, 'UTF-8', propertiespattern, null, null)
		}
		ant.fileset(dir: "$dir1", includes:'**/*.dtd', excludes:excludes).each {
			parse(dir1, it, 'UTF-8', dtdpattern, null, null)
		}
		ant.fileset(dir: "$dir2", includes:'**/*.dtd', excludes:excludes).each {
			parse(dir2, it, 'UTF-8', dtdpattern, null, null)
		}
		
		// to avoid ignoring existing blank file, check if it is null
		l10n1 = l10n[dir1].groupBy { k,v -> l10n[dir2][k] != null ? 'common' : 'unique' }
		l10n2 = l10n[dir2].groupBy { k,v -> l10n[dir1][k] != null ? 'common' : 'unique' }
		// groupBy will not set empty map when nothing match and need to set empty map
		l10n1.common = l10n1.common ?: [:]
		l10n2.common = l10n2.common ?: [:]
		l10n1.unique = l10n1.unique ?: [:]
		l10n2.unique = l10n2.unique ?: [:]
		assert l10n1.common.size() == l10n2.common.size()
		infomsg << "Number of files in the $dir1 directory:\n"
		infomsg << "    total: ${l10n[dir1].size()}, common: ${l10n1.common.size()}, unique: ${l10n1.unique.size()}\n\n"
		infomsg << "Number of files in the $dir2 directory:\n"
		infomsg << "    total: ${l10n[dir2].size()}, common: ${l10n2.common.size()}, unique: ${l10n2.unique.size()}\n\n"
		
		// Phase 2: Unique L10N Files
		if (l10n1.unique) {
			fileerrmsg << "File(s) only in $dir1 directory:\n"
			l10n1.unique.each { filekey,entities ->
				fileerrmsg << "    $filekey \t(${entities.size()?:0} entities)\n"
				uniquekeys1 += entities.size()?:0
			}
		}
		if (l10n2.unique) {
			fileerrmsg << "File(s) only in $dir2 directory:\n"
			l10n2.unique.each { filekey,entities ->
				fileerrmsg << "    $filekey \t(${entities.size()?:0} entities)\n"
				uniquekeys2 += entities.size()?:0
			}
		}
		
		// Phase 3: Common L10N Files
		l10n1.common.each { filekey, allentities1 ->
			allentities2 = l10n2.common[filekey]
			entities1 = allentities1.groupBy { k,v -> allentities2[k] != null ? 'common' : 'unique' }
			entities2 = allentities2.groupBy { k,v -> allentities1[k] != null ? 'common' : 'unique' }
			entities1.common = entities1.common ?: [:]
			entities2.common = entities2.common ?: [:]
			entities1.unique = entities1.unique ?: [:]
			entities2.unique = entities2.unique ?: [:]
			assert entities1.common.size() == entities2.common.size()
			commonkeys  += entities1.common.size() - entities1.unique.size()
			uniquekeys1 += entities1.unique.size()
			uniquekeys2 += entities2.unique.size()
			// Phase 3-1: Unique Entities
			if (entities1.unique || entities2.unique) {
				entityerrmsg << "Entities in this file don't match: $filekey:\n"
				if (entities1.unique) {
					entityerrmsg << "    Only in $dir1/$filekey:\n"
					entities1.unique.each { key,block -> entityerrmsg << "        $key \t= ${block.value}\n" }
				}
				if (entities2.unique) {
					entityerrmsg << "    Only in $dir2/$filekey:\n"
					entities2.unique.each { key,block -> entityerrmsg << "        $key \t= ${block.value}\n" }
				}
				entityerrmsg << "\n"
			}
			// Phase 3-2: Common Entities
			entities1.common.each { key,block1 ->
				block2 = entities2.common[key]
				// Check Accesskey Entities
				if (key =~ /\.accesskey$/ && block1.value != block2.value) {
					accesskeymsg << "Accesskey(s) in this file don't match: $filekey:\n"
					accesskeymsg << "    $key:  ${block1.value} != ${block2.value}\n"
					
					
				}
				// Merge L10N Files
				
				
			}
		}
		infomsg << "Total Number of entities in the $dir1 directory:\n"
		infomsg << "    total: ${commonkeys+uniquekeys1}, common: $commonkeys, unique: $uniquekeys1\n\n"
		infomsg << "Total Number of entities in the $dir2 directory:\n"
		infomsg << "    total: ${commonkeys+uniquekeys2}, common: $commonkeys, unique: $uniquekeys2\n\n"
		
		println "$infomsg"
		
		if (fileerrmsg || entityerrmsg) {
			new File('@{output}').append("$infomsg\n\n$fileerrmsg\n\n$entityerrmsg\n\n$accesskeymsg")
			if (failonerror) ant.fail "Compare Locale Error:\n\n$fileerrmsg\n\n$entityerrmsg\n\n$accesskeymsg"
		}
	]]></groovy>
	</sequential>
</macrodef>
<target name="compare-locales-ja" depends="load-mainconf" unless="locale">
	<compare-locales dir2="${lot.l10n.dir}/ja" excludes="${compare-locales.excludes}" failonerror="true"/>
	<compare-locales dir2="${lot.l10n.dir}/ja-JP-mac" excludes="${compare-locales.excludes}" failonerror="true"/>
</target>
<target name="compare-locales" depends="load-mainconf, compare-locales-ja" if="locale">
	<compare-locales dir2="${lot.l10n.dir}/${locale}" excludes="${compare-locales.excludes}" failonerror="true"/>
</target>


<target name="syntaxcheck" depends="load-conf" unless="nosyntaxcheck"
	description="syntax error check of converted files">
	<fail message="${cmsg.noprop.syntaxcheck.src.dir}" unless="syntaxcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.syntaxcheck\."/>
	<fail message="${vmsg.syntaxcheck.no.srcdir}">
		<condition><not><available file="${syntaxcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<property name="syntaxcheck.output"  value="temp/syntaxerror.txt"/>
	<delete file="${syntaxcheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		errormsg = new StringBuilder()
		def syntaxchecker(file, encoding, validpattern) {
			content = new StringBuilder()
			file.getFile().getText(encoding).eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
			content = content.toString().replaceAll(validpattern, '')
			if (content) errormsg << "Syntax Error Found in $file:\n$content\n\n"
		}
		
		ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.properties').each {
			syntaxchecker(it, 'UTF-8', /(?m)${properties.'RE.properties.validline'}\n/)
		}
		ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.dtd').each {
			syntaxchecker(it, 'UTF-8', /(?ms)${properties.'RE.dtd.validblock'}\n/)
		}
		// need to support *.ini, *.inc files too...
		//ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.ini').each {
		//	syntaxchecker(it, 'UTF-8', /(?ms)${properties.'RE.ini.validblock'}\n/)
		//}
		//ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.inc').each {
		//	syntaxchecker(it, 'UTF-8', /(?ms)${properties.'RE.inc.validblock'}\n/)
		//}
		
		if (errormsg) {
			new File(properties.'syntaxcheck.output').append(errormsg)
			ant.fail(taskname: 'syntaxcheck', message:"$errormsg${properties.'vmsg.syntaxcheck.found'}")
		}
	]]></groovy>
</target>

<target name="placeholdercheck" depends="load-conf" unless="noplaceholdercheck"
	description="placeholder usage error check of converted properties files">
	<fail message="${cmsg.noprop.placeholdercheck.src.dir}" unless="placeholdercheck.src.dir"/>
	<loadmessage pattern="^vmsg\.placeholdercheck\."/>
	<fail message="${vmsg.placeholdercheck.no.srcdir}">
		<condition><not><available file="${placeholdercheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<property name="placeholdercheck.output"  value="temp/placeholdererror.txt"/>
	<delete file="${placeholdercheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		max = 5
		errormsg = new StringBuilder()
		ant.fileset(dir: properties.'placeholdercheck.src.dir', includes:'**/*.properties').each {
			errorlines = new StringBuilder()
			it.getFile().getText('UTF-8').eachLine { line, n ->
				err = false
				(2..max).each { i -> // search %2$2, %3$S...
					if (!err && line =~ "^[^#].+=.+%$i\\\$S") {
						(1..<i).each { j -> // confirm if smaller number placeholders are defined
							err = err || (!line.contains("%$j\$S") && !line.contains("%$j\$0.S"))
						}
					}
				}
				if (err) errorlines << "@line ${n+1}: $line\n"
			}
			if (errorlines) errormsg << "Placeholder Error Found in $it:\n$errorlines\n\n"
		}
		if (errormsg) {
			new File(properties.'placeholdercheck.output').append(errormsg)
			ant.fail(taskname: 'placeholdercheck', message:"$errormsg${properties.'vmsg.placeholdercheck.found'}")
		}
	]]></groovy>
</target>

<target name="pluralcheck" depends="load-conf" unless="nopluralcheck"
	description="plural form error check of converted properties files">
	<loadmessage pattern="^vmsg\.pluralcheck\."/>
	<property name="pluralcheck.output"	value="temp/pluralcheck.txt"/>
	<delete file="${pluralcheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		errormsg = new StringBuilder()
		ant.fileset(dir: properties.'pluralcheck.src.dir', includes:'**/*.properties').each {
			errorlines = new StringBuilder()
			it.getFile().getText('UTF-8').replaceAll(/(?ms)${properties.'pluralcheck.allow'}/, properties.'pluralcheck.allow.replace').eachLine { line, n ->
				if (line =~ /^\s*[-0-9a-zA-Z_.?{@}]+\s*=.+;.+/) {
					errorlines << "@line ${n+1}: $line\n"
				}
			}
			if (errorlines) errormsg << "Syntax Error Found in $it:\n$errorlines\n\n"
		}
		if (errormsg) {
			new File(properties.'pluralcheck.output').append(errormsg)
			ant.echo(taskname: 'pluralcheck', message:"$errormsg${properties.'vmsg.pluralcheck.found'}")
		}
	]]></groovy>
</target>


<macrodef name="wordchecksuite">
	<!-- macrodef 配下の groovy タスクでは @{attribute} を展開したものが groovy のソースとして解釈実行される。但し、属性のデフォルト値に Ant のプロパティ展開式を記述した場合、macrodef 定義時に設定済みのプロパティは展開済みの値が groovy のソースに挿入されるが、macrodef 定義時に未設定のプロパティは展開式のまま groovy のソースに挿入される。文字列リテラル中に @{attribute} を含める場合、GString として解釈されて構文エラーを引き起こさないように注意が必要。 -->
	<!-- allowpattern, denypattern 属性では(スラッシュ以外には)バックスラッシュのエスケープが必要とならないようにスラッシュ文字列リテラルに含めるが、GString が有効になるので Ant のプロパティをデフォルト値には定義できない。default="${properties.'wordcheck.allow'}" などと指定することもできるが、この場合属性値を受け取った場合にはスラッシュのエスケープが必要だがデフォルト値ではエスケープしてはならないというフォーマットが不統一になる。 -->
	<attribute name="allowpattern"/><!-- Java Regexp (exception: slash have to be escaped and ${} will be replaced) -->
	<attribute name="denypattern"/><!-- Java Regexp (exception: slash have to be escaped and ${} will be replaced) -->
	<attribute name="replacement" default="${properties.'wordcheck.deny.replace'}"/>
	<attribute name="dir"/>
	<attribute name="output"/>
	<attribute name="excludes" default=""/>
	<attribute name="regexpengine" default=""/>
	<sequential><!-- 並列処理にすれば高速化可能... -->
		<!-- groovy を使うと allowpattern をスラッシュ文字列リテラルに代入するためスラッシュのエスケープが必要 -->
		<groovy><![CDATA[
			import org.apache.oro.text.regex.*;
			allowpattern       = /(?m)@{allowpattern}/
			denypattern        = /(?m)@{denypattern}/
			denypattern_       = ~/(?m)@{denypattern}/
			replacement        = /@{replacement}/
			xmlcommentpattern  = /(?ms)${properties.'RE.xml.comment'}/
			linecommentpattern = /(?m)^(@line [0-9]+: )?\s*#[^\n]*/
			errormsg           = new StringBuilder()
			def wordchecker(file, encoding, allowpattern, denypattern, commentpattern) {
				errorlines = new StringBuilder()
				content = new StringBuilder()
				file.getFile().getText(encoding).eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
				if (commentpattern) {
					content = content.toString().replaceAll(commentpattern, '')
				}
				if (allowpattern) {
					content = content.toString().replaceAll(allowpattern, properties.'wordcheck.allow.replace')
				}
				
				if ('@{regexpengine}' == 'jakartaoro') {
					PatternMatcher matcher = new Perl5Matcher();
					PatternCompiler compiler = new Perl5Compiler();
					Pattern pattern = compiler.compile("($denypattern)");
					content.eachLine { line, n ->
						if (matcher.contains(line, pattern)) {
							errorlines << Util.substitute(matcher, pattern, new Perl5Substitution(replacement, Perl5Substitution.INTERPOLATE_ALL), line, Util.SUBSTITUTE_ALL) + "\n"
						}
					}
				}
				else {
					content.eachLine { line, n ->
						if (line =~ denypattern_) {
							errorlines << line.toString().replaceAll("($denypattern)", replacement) + "\n"
						}
					}
				}
				if (errorlines) errormsg << "Error Found in $file:\n$errorlines\n\n"
			}
			
			ant.fileset(dir: '@{dir}', includes:'**/*.dtd, ${xmlfiles}', excludes:'@{excludes}').each {
				wordchecker(it, 'UTF-8', allowpattern, denypattern, xmlcommentpattern)
			}
			if (properties.'wordcheck.unescape.properties') {
				// note: native2ascii task require JDK installed and JAVA_HOME env set properly, or you'll see the error "error starting Sun's native2ascii"
				ant.native2ascii(src:'@{dir}', includes:'**/*.properties',
					dest:'${lot.temp.dir}/wordcheck', reverse:true, encoding:'UTF-8')
				ant.fileset(dir: '${lot.temp.dir}/wordcheck', includes:'**/*.properties', excludes:'@{excludes}').each {
					wordchecker(it, 'UTF-8', allowpattern, denypattern, linecommentpattern)
				}
				ant.delete(dir:'${lot.temp.dir}/wordcheck', failonerror:false)
			}
			else {
				ant.fileset(dir: '@{dir}', includes:'**/*.properties', excludes:'@{excludes}').each {
					wordchecker(it, 'UTF-8', allowpattern, denypattern, linecommentpattern)
				}
			}
			ant.fileset(dir: '@{dir}', includes:'**/*.inc, **/unix/*.it', excludes:'@{excludes}').each {
				wordchecker(it, 'UTF-8', allowpattern, denypattern, null)
			}
			ant.fileset(dir: '@{dir}', includes:'${sjisfiles}', excludes:'@{excludes}').each {
				wordchecker(it, 'Shift_JIS', allowpattern, denypattern, null)
			}
			if (errormsg) new File('@{output}').append(errormsg)
		]]></groovy>
	</sequential>
</macrodef>
<target name="wordcheck" depends="load-conf" unless="nowordcheck">
	<fail message="${cmsg.noprop.wordcheck.src.dir}" unless="wordcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.wordcheck\."/>
	<fail message="${vmsg.wordcheck.no.srcdir}">
		<condition><not><available file="${wordcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	<property name="wordcheck.output"  value="temp/worderror.txt"/>
	<delete file="${wordcheck.output}" failonerror="false"/>
	
	<equals property="wordcheck.deny"	value="@{2}|${wordcheck.deny.common}|${wordcheck.deny.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.deny"	value="@{2}|${wordcheck.deny.common}|${wordcheck.deny.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	<property name="wordcheck.deny"		value="${wordcheck.deny.common}"/>
	<equals property="wordcheck.allow"	value="${wordcheck.allow.common}|${wordcheck.allow.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.allow"	value="${wordcheck.allow.common}|${wordcheck.allow.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	<property name="wordcheck.allow"	value="${wordcheck.allow.common}"/>
	
	<wordchecksuite dir="${wordcheck.src.dir}" output="${wordcheck.output}"
		excludes="browser/, calendar/, editor/, mail/, mobile/, suite/"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/browser" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.firefox}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/calendar" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.sunbird}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/editor" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.thunderbird}|${wordcheck.deny.seamonkey}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/mail" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.thunderbird}|${wordcheck.deny.seamonkey}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/mobile" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.fennec}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/suite" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.seamonkey}"/>
	
	<loadfile property="wordcheck.error" srcfile="${wordcheck.output}" encoding="UTF-8" failonerror="false"/>
	<fail message="${N}${wordcheck.error}${vmsg.wordcheck.found}" if="wordcheck.error"/>
</target>
<target name="suspectedwordcheck" depends="load-conf" unless="nosuspectedwordcheck" if="dosuspectedwordcheck">
	<delete file="${wordcheck.suspected.output}" failonerror="false"/>
	
	<equals property="wordcheck.suspected"	value="@{2}|${wordcheck.suspected.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.suspected"	value="@{2}|${wordcheck.suspected.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	
	<wordchecksuite dir="${wordcheck.src.dir}" output="${wordcheck.suspected.output}"
		allowpattern="##NOTHING##" denypattern="${wordcheck.suspected}"/>
</target>

<!-- currently off by default -->
<target name="charcheck" depends="load-conf" unless="nocharcheck">
	<delete file="${charcheck.output}" failonerror="false"/>
	
	<fail message="${cmsg.noprop.charcheck.src.dir}" unless="charcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.charcheck\."/>
	<fail message="${vmsg.charcheck.no.srcdir}">
		<condition><not><available file="${charcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<wordchecksuite dir="${charcheck.src.dir}" output="${charcheck.output}" excludes="${charcheck.excludes}"
		allowpattern="${charcheck.allow}" denypattern="${charcheck.deny}" replacement="${charcheck.deny.replace}"
		regexpengine="jakartaoro"/>
	
	<loadfile property="charcheck.error" srcfile="${charcheck.output}" encoding="UTF-8" failonerror="false"/>
	<echo></echo>
	<fail if="charcheck.error">${N}${charcheck.error}${vmsg.charcheck.found}{$}使用不可と検出された文字のリストを取得したい場合は次の(一行の)コマンドを実行してください:${N}cat ${charcheck.output} | perl -pe 'use utf8; use encoding ("utf-8"); s/^[^\[\]]*(\[CHARERROR\[([^\]]+)\]CHARERROR\])?[^\[\]]*|[^\[\]]*|^Error.+/$1\n/g; s/CHARERROR|[\[\]\s]//g; s/(.)/$1\n/g;' | sort | uniq</fail>
</target>

<target name="errorcheck" depends="syntaxcheck, placeholdercheck, pluralcheck, wordcheck, suspectedwordcheck, charcheck"/>



<!-- * escape and unescape * -->
<!-- switching unicode escape from/to utf-8 (only *.properties files are escaped/unescaped and others are just copied by default) -->
<target name="-escape-jar-" depends="load-mainconf" if="escape.jar.file">
	<property name="escape.jar.dir" value="${escape.todir}"/>
	<zip taskname="JAR Packaging (${escape.jar.file})" destfile="${escape.jar.dir}/${escape.jar.file}" compress="false" update="false">
		<zipfileset dir="${escape.todir}/" excludes="${escape.jar.file}"/>
	</zip>
</target>
<target name="escape" depends="load-mainconf"
	description="escape *.properties files and copy other files">
	<loadmessage pattern="^vmsg\.escape\."/>
	<fail message="${vmsg.escape.no.fromdir}">
		<condition><not><available file="${escape.fromdir}" type="dir"/></not></condition>
	</fail>
	<escapeunicode-copy fromdir="${escape.fromdir}" todir="${escape.todir}" encoding="${escape.encoding}"
		includes="${escape.includes}" excludes="${escape.excludes}"
		escapeincludes="${escape.escapeincludes}" escapeexcludes="${escape.escapeexcludes}"/>
	<antcall target="-escape-jar-"/>
</target>

<target name="-unescape-jar-" depends="load-mainconf" if="unescape.jar.file">
	<unjar src="${unescape.jar.file}"
		dest="${unescape.fromdir}"/>
</target>
<target name="unescape" depends="load-mainconf, -unescape-jar-"
	description="unescape *.properties files and copy other files">
	<loadmessage pattern="^vmsg\.unescape\."/>
	<fail message="${vmsg.unescape.no.fromdir}">
		<condition><not><available file="${unescape.fromdir}" type="dir"/></not></condition>
	</fail>
	<unescapeunicode-copy fromdir="${unescape.fromdir}" todir="${unescape.todir}" encoding="${unescape.encoding}"
		includes="${unescape.includes}" excludes="${unescape.excludes}"
		unescapeincludes="${unescape.unescapeincludes}" unescapeexcludes="${unescape.unescapeexcludes}"/>
</target>



<!-- * en-US to l10n * -->
<target name="prepare-hg">
	<!-- prepare properties to make this script possible to use stand alone -->
	<property name="lot.temp.dir" value="temp"/>
	<property name="locale" value="ja"/>
	<property name="hg.mozilla.dir" value="comm-central/mozilla"/>
	<property name="hg.comm.dir" value="comm-central"/>
	<property name="hg.mobile.dir" value="mobile-browser"/>
</target>

<target name="mozilla-to-l10n" depends="prepare-hg"
	description="copy changing directory structure of en-US locale files within mozilla repository">
	<!-- prepare properties to make this script possible to use stand alone -->
	<property name="mozilla-to-l10n.temp.dir" value="${lot.temp.dir}/mozilla-to-l10n"/>
	<property name="mozilla-to-l10n.dir" value="${lot.l10n.dir}/en-US"/>
	
	<!-- cleaning -->
	<delete dir="${mozilla-to-l10n.temp.dir}"/>
	
	<!-- now, copy changing directory structure -->
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/browser"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/browser/locales/en-US"/>
	</copy><!-- only firefox -->
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/dom"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/dom/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/inspector/chrome"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/inspector/resources/locale/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/irc"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/irc/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/spellcheck"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/spellcheck/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/reporter"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/reporter/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/venkman"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/venkman/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/netwerk"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/netwerk/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/other-licenses/branding/firefox"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/other-licenses/branding/firefox/locales/en-US"/>
	</copy><!-- only firefox -->
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/security/manager"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/security/manager/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/toolkit"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/toolkit/locales/en-US"/>
	</copy>
	
	<mkdir dir="${mozilla-to-l10n.dir}"/>
	<move todir="${mozilla-to-l10n.dir}">
		<fileset dir="${mozilla-to-l10n.temp.dir}/en-US"/>
	</move>
</target>

<target name="comm-to-l10n" depends="prepare-hg"
	description="copy changing directory structure of en-US locale files within comm repository">
	<!-- prepare properties to make this script possible to use stand alone -->
	<property name="comm-to-l10n.temp.dir" value="${lot.temp.dir}/comm-to-l10n"/>
	<property name="comm-to-l10n.dir" value="${lot.l10n.dir}/en-US"/>
	
	<!-- cleaning -->
	<delete dir="${comm-to-l10n.temp.dir}"/>
	
	<!-- now, copy changing directory structure -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/calendar"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/calendar/locales/en-US"/>
	</copy><!-- only sunbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/editor/ui"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/editor/ui/locales/en-US"/>
	</copy><!-- only thunderbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/mail"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/mail/locales/en-US"/>
	</copy><!-- only thunderbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/other-licenses/branding/sunbird"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/other-licenses/branding/sunbird/locales/en-US"/>
	</copy><!-- only sunbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/other-licenses/branding/thunderbird"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/other-licenses/branding/thunderbird/locales/en-US"/>
	</copy><!-- only thunderbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/suite"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/suite/locales/en-US"/>
	</copy><!-- only seamonkey -->
	
	<mkdir dir="${comm-to-l10n.dir}"/>
	<move todir="${comm-to-l10n.dir}">
		<fileset dir="${comm-to-l10n.temp.dir}/en-US"/>
	</move>
</target>

<target name="mobile-to-l10n" depends="prepare-hg"
	description="copy changing directory structure of en-US locale files within mobile-browser">
	<property name="mobile-to-l10n.dir" value="${lot.l10n.dir}/en-US"/>
	<mkdir dir="${mobile-to-l10n.dir}/mobile"/>
	<copy todir="${mobile-to-l10n.dir}/mobile" failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mobile.dir}/locales/en-US"/>
	</copy>
</target>

<target name="en-US-to-l10n" depends="mozilla-to-l10n, comm-to-l10n, mobile-to-l10n"
       description="copy changing directory structure of en-US locale files within both mozilla and comm repository"/>



<!-- * better to have * -->
<target name="imedic"
	description="generate IME dictionary for filters">
	<!-- 例えば "ウィンドウ" で "@@Window@@" に変換するための辞書を生成 -->
	<fail message="not implemented yet..."/>
</target>


</project>
