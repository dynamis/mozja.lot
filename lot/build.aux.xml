<?xml version="1.0" encoding="UTF-8"?>
<project name="aux" default="" basedir=".">
<description>auxiliary targets</description>
<property name="buildfile.aux.loaded" value="true"/>


<!-- * update and commit lot itself * -->
<target name="checkout-src" depends="load-mainconf"
	description="checkout src files from l10n svn server">
	<exec executable="svn" taskname="svn">
		<!-- svn+ssh://svn.mozilla.l10n.jp/usr/local/var/svn/l10n/trunk/ -->
		<arg line="checkout http://svn.mozilla.l10n.jp/trunk/ ${lot.src.dir}/l10n"/>
	</exec>
</target>
<target name="update-src" depends="load-mainconf"
	description="update src files in the working directory">
	<exec executable="svn" taskname="svn">
		<arg line="update ${lot.src.dir}/l10n"/>
	</exec>
</target>
<target name="update-lot" depends="load-mainconf"
	description="replace current lot with checkouted lot (src/l10n/lot)">
	<confirm message="現在使用中の Localization Tools を L10N SVN の最新バージョンで置き換えます。本当に置き換えてよろしいですか？(Y/N)"
		failmessage="Localization Tools の 置き換えを中止しました"/>
	<property name="update-lot.dir" value="${lot.src.dir}/l10n/lot"/>
	<exec executable="svn" taskname="svn">
		<arg line="update ${update-lot.dir}"/>
	</exec>
	<copy todir="." preservelastmodified="true" overwrite="true">
		<fileset dir="${update-lot.dir}" defaultexcludes="yes"
			includes="${backuplot.includes}" excludes="${backuplot.excludes}"/>
	</copy>
</target>
<target name="update" depends="update-src, update-lot"
	description="update src and lot itself from svn server"/>

<target name="pre-commit-lot" depends="load-mainconf"
	description="copy current lot to svn working directory (src/l10n/lot)">
	<copy todir="${lot.src.dir}/l10n/lot" preservelastmodified="true">
		<fileset dir="." defaultexcludes="no"
			includes="${backuplot.includes}" excludes="${backuplot.excludes}"/>
	</copy>
</target>
<target name="commit-lot" depends="pre-commit-lot"
	description="commit current lot to l10n svn server">
	<property name="commit-lot.dir" value="${lot.src.dir}/l10n/lot"/>
	<input message="コミットログを入力してください:"
		addproperty="commit-lot.message" defaultvalue=""/>
	<fail message="コミットログが指定されていません。">
		<condition><equals arg1="${commit-lot.message}" arg2="" trim="true"/></condition>
	</fail>
	<confirm message='${commit-lot.dir} ディレクトリで次の cvs commit コマンドを実行しようとしています:${N}
		svn commit -m "${commit-lot.message}"${N}本当に実行してもよろしいですか？(Y/N)'
		failmessage="svn commit を中止しました。"/>
	<exec executable="svn" taskname="svn" dir="${commit-lot.dir}">
		<arg line='commit -m "${commit-lot.message}"'/>
	</exec>
</target>



<!-- * backup and restore * -->
<target name="backupsrc" depends="load-mainconf" unless="nobackup"
	description="backup whole src files">
	<mkdir dir="${backupsrc.dir}"/>
	<zip destfile="${backupsrc.file}">
		<zipfileset dir="." defaultexcludes="no"
			includes="${backupsrc.includes}" excludes="${backupsrc.excludes}"/>
	</zip>
</target>

<target name="restoresrc" depends="load-mainconf" unless="norestore"
	description="restore whole src files">
	<loadmessage pattern="^vmsg\.restoresrc\."/>
	<fail message="${vmsg.restoresrc.notfound}">
		<condition><not><available file="${restoresrc.file}" type="file"/></not></condition>
	</fail>
	<confirm message="${vmsg.restoresrc.confirm}" failmessage="${cmsg.restoresrc.cancelled}"/>
	
	<condition property="nobackup">
		<not><available file="${lot.src.dir}" type="dir"/></not>
	</condition>
	<antcall target="backupsrc"/>
	
	<unzip src="${restoresrc.file}" dest="${lot.temp.dir}/restore"/>
	<delete dir="${lot.src.dir}/"/>
	<move todir="${lot.src.dir}">
		<fileset dir="${lot.temp.dir}/restore/${lot.src.dir}"/>
	</move>
</target>

<target name="backuplot" depends="load-mainconf" unless="nobackup"
	description="zip localization tools">
	<mkdir dir="${backuplot.dir}"/>
	<zip destfile="${backuplot.file}">
		<zipfileset dir="." defaultexcludes="no"
			includes="${backuplot.includes}" excludes="${backuplot.excludes}"/>
	</zip>
</target>

<target name="backup" depends="load-mainconf" unless="nobackup"
	description="zip localization tools with src files">
	<mkdir dir="${backup.dir}"/>
	<zip destfile="${backup.file}">
		<zipfileset dir="." defaultexcludes="no"
			includes="${backup.includes}" excludes="${backup.excludes}"/>
	</zip>
</target>


<!-- * error check * -->
<target name="get-compare-locales" depends="load-mainconf">
	<get src="${compare-locales.get.url}" dest="${compare-locales.file}"/>
</target>
<macrodef name="compare-locales">
	<attribute name="fromlocale" default="en-US"/>
	<attribute name="tolocale" default="ja"/>
	<attribute name="failonerror" default="false"/>
	<sequential>
		<exec taskname="perl" executable="perl" failonerror="@{failonerror}">
			<arg line="${compare-locales.file} ${lot.l10n.dir}/@{fromlocale} ${lot.l10n.dir}/@{tolocale}"/>
		</exec>
	</sequential>
</macrodef>
<target name="compare-locales-ja" depends="load-mainconf" unless="locale">
	<compare-locales tolocale="ja"/>
	<compare-locales tolocale="ja-JP-mac"/>
</target>
<target name="compare-locales" depends="load-mainconf, compare-locales-ja" if="locale">
	<compare-locales tolocale="${locale}" failonerror="true"/>
</target>


<target name="syntaxcheck" depends="load-conf" unless="nosyntaxcheck"
	description="syntax error check of converted files">
	<fail message="${cmsg.noprop.syntaxcheck.src.dir}" unless="syntaxcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.syntaxcheck\."/>
	<fail message="${vmsg.syntaxcheck.no.srcdir}">
		<condition><not><available file="${syntaxcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<property name="syntaxcheck.output"  value="temp/syntaxerror.txt"/>
	<delete file="${syntaxcheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		errormsg = new StringBuilder()
		// find error in properties files
		ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.properties').each {
			content = new StringBuilder()
			it.getFile().getText('UTF-8').eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
			content = content.toString().replaceAll(/(?m)${properties.'RE.properties.validline'}\n/, '')
			if (content) errormsg << "Syntax Error Found in $it:\n$content\n\n"
		}
		// find error in dtd files
		ant.fileset(dir: properties.'syntaxcheck.src.dir', includes:'**/*.dtd').each {
			content = new StringBuilder()
			it.getFile().getText('UTF-8').eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
			content = content.toString().replaceAll(/(?ms)${properties.'RE.dtd.validblock'}\n/, '')
			if (content) errormsg << "Syntax Error Found in $it:\n$content\n\n"
		}
		if (errormsg) {
			new File(properties.'syntaxcheck.output').append(errormsg)
			ant.fail(taskname: 'syntaxcheck', message:"$errormsg${properties.'vmsg.syntaxcheck.found'}")
		}
	]]></groovy>
</target>

<target name="placeholdercheck" depends="load-conf" unless="noplaceholdercheck"
	description="placeholder usage error check of converted properties files">
	<fail message="${cmsg.noprop.placeholdercheck.src.dir}" unless="placeholdercheck.src.dir"/>
	<loadmessage pattern="^vmsg\.placeholdercheck\."/>
	<fail message="${vmsg.placeholdercheck.no.srcdir}">
		<condition><not><available file="${placeholdercheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<property name="placeholdercheck.output"  value="temp/placeholdererror.txt"/>
	<delete file="${placeholdercheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		max = 5
		errormsg = new StringBuilder()
		ant.fileset(dir: properties.'placeholdercheck.src.dir', includes:'**/*.properties').each {
			errorlines = new StringBuilder()
			it.getFile().getText('UTF-8').eachLine { line, n ->
				err = false
				(2..max).each { i ->
					if (!err && line =~ "^[^#].+=.+%$i\\\$S") {
						(1..<i).each { j ->
							err = err || (!line.contains("%$j\$S") && !line.contains("%$j\$0.S"))
						}
					}
				}
				if (err) errorlines << "@line ${n+1}: $line\n"
			}
			if (errorlines) errormsg << "Placeholder Error Found in $it:\n$errorlines\n\n"
		}
		if (errormsg) {
			new File(properties.'placeholdercheck.output').append(errormsg)
			ant.fail(taskname: 'placeholdercheck', message:"$errormsg${properties.'vmsg.placeholdercheck.found'}")
		}
	]]></groovy>
</target>

<target name="pluralcheck" depends="load-conf" unless="nopluralcheck"
	description="plural form error check of converted properties files">
	<loadmessage pattern="^vmsg\.pluralcheck\."/>
	<property name="pluralcheck.output"	value="temp/pluralcheck.txt"/>
	<delete file="${pluralcheck.output}" failonerror="false"/>
	
	<groovy><![CDATA[
		errormsg = new StringBuilder()
		ant.fileset(dir: properties.'pluralcheck.src.dir', includes:'**/*.properties').each {
			errorlines = new StringBuilder()
			it.getFile().getText('UTF-8').replaceAll(/(?ms)${properties.'pluralcheck.allow'}/, properties.'pluralcheck.allow.replace').eachLine { line, n ->
				if (line =~ /^\s*[-0-9a-zA-Z_.?{@}]+\s*=.+;.+/) {
					errorlines << "@line ${n+1}: $line\n"
				}
			}
			if (errorlines) errormsg << "Syntax Error Found in $it:\n$errorlines\n\n"
		}
		if (errormsg) {
			new File(properties.'pluralcheck.output').append(errormsg)
			ant.echo(taskname: 'pluralcheck', message:"$errormsg${properties.'vmsg.pluralcheck.found'}")
		}
	]]></groovy>
</target>


<macrodef name="wordchecksuite">
	<!-- macrodef 配下の groovy タスクでは @{attribute} を展開したものが groovy のソースとして解釈実行される。但し、属性のデフォルト値に Ant のプロパティ展開式を記述した場合、macrodef 定義時に設定済みのプロパティは展開済みの値が groovy のソースに挿入されるが、macrodef 定義時に未設定のプロパティは展開式のまま groovy のソースに挿入される。文字列リテラル中に @{attribute} を含める場合、GString として解釈されて構文エラーを引き起こさないように注意が必要。 -->
	<!-- allowpattern, denypattern 属性では(スラッシュ以外には)バックスラッシュのエスケープが必要とならないようにスラッシュ文字列リテラルに含めるが、GString が有効になるので Ant のプロパティをデフォルト値には定義できない。default="${properties.'wordcheck.allow'}" などと指定することもできるが、この場合属性値を受け取った場合にはスラッシュのエスケープが必要だがデフォルト値ではエスケープしてはならないというフォーマットが不統一になる。 -->
	<attribute name="allowpattern"/><!-- Java Regexp (exception: slash have to be escaped and ${} will be replaced) -->
	<attribute name="denypattern"/><!-- Java Regexp (exception: slash have to be escaped and ${} will be replaced) -->
	<attribute name="replacement" default="${properties.'wordcheck.deny.replace'}"/>
	<attribute name="dir"/>
	<attribute name="output"/>
	<attribute name="excludes" default=""/>
	<sequential><!-- 並列処理にすれば高速化可能... -->
		<!-- groovy を使うと allowpattern をスラッシュ文字列リテラルに代入するためスラッシュのエスケープが必要 -->
		<groovy><![CDATA[
			allowpattern       = /(?m)@{allowpattern}/
			denypattern        = /(?m)@{denypattern}/
			replacement        = /@{replacement}/
			xmlcommentpattern  = /(?ms)${properties.'RE.xml.comment'}/
			linecommentpattern = /(?m)^(@line [0-9]+: )?\s*#[^\n]*/
			def wordchecker(file, encoding, allowpattern, denypattern, commentpattern) {
				errorlines = new StringBuilder()
				content = new StringBuilder()
				file.getFile().getText(encoding).eachLine{ line,n -> content << "@line ${n+1}: $line\n" }
				if (commentpattern) {
					content = content.toString().replaceAll(commentpattern, '')
				}
				if (allowpattern) {
					content = content.toString().replaceAll(allowpattern, properties.'wordcheck.allow.replace')
				}
				content.eachLine { line, n ->
					if (line =~ denypattern) {
						errorlines << line.replaceAll("($denypattern)", replacement) + "\n"
					}
				}
				if (errorlines) errormsg << "Error Found in $file:\n$errorlines\n\n"
			}
			errormsg = new StringBuilder()
			
			ant.fileset(dir: '@{dir}', includes:'**/*.dtd, ${xmlfiles}', excludes:'@{excludes}').each {
				wordchecker(it, 'UTF-8', allowpattern, denypattern, xmlcommentpattern)
			}
			if (properties.'wordcheck.unescape.properties') {
				// note: native2ascii task require JDK installed and JAVA_HOME env set properly, or you'll see the error "error starting Sun's native2ascii"
				ant.native2ascii(src:'@{dir}', includes:'**/*.properties',
					dest:'${lot.temp.dir}/wordcheck', reverse:true, encoding:'UTF-8')
				ant.fileset(dir: '${lot.temp.dir}/wordcheck', includes:'**/*.properties', excludes:'@{excludes}').each {
					wordchecker(it, 'UTF-8', allowpattern, denypattern, linecommentpattern)
				}
				ant.delete(dir:'${lot.temp.dir}/wordcheck', failonerror:false)
			}
			else {
				ant.fileset(dir: '@{dir}', includes:'**/*.properties', excludes:'@{excludes}').each {
					wordchecker(it, 'UTF-8', allowpattern, denypattern, linecommentpattern)
				}
			}
			ant.fileset(dir: '@{dir}', includes:'**/*.inc, **/unix/*.it', excludes:'@{excludes}').each {
				wordchecker(it, 'UTF-8', allowpattern, denypattern, null)
			}
			ant.fileset(dir: '@{dir}', includes:'${sjisfiles}', excludes:'@{excludes}').each {
				wordchecker(it, 'Shift_JIS', allowpattern, denypattern, null)
			}
			if (errormsg) new File('@{output}').append(errormsg)
		]]></groovy>
	</sequential>
</macrodef>
<target name="wordcheck" depends="load-conf" unless="nowordcheck">
	<fail message="${cmsg.noprop.wordcheck.src.dir}" unless="wordcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.wordcheck\."/>
	<fail message="${vmsg.wordcheck.no.srcdir}">
		<condition><not><available file="${wordcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	<property name="wordcheck.output"  value="temp/worderror.txt"/>
	<delete file="${wordcheck.output}" failonerror="false"/>
	
	<equals property="wordcheck.deny"	value="@{2}|${wordcheck.deny.common}|${wordcheck.deny.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.deny"	value="@{2}|${wordcheck.deny.common}|${wordcheck.deny.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	<property name="wordcheck.deny"		value="${wordcheck.deny.common}"/>
	<equals property="wordcheck.allow"	value="${wordcheck.allow.common}|${wordcheck.allow.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.allow"	value="${wordcheck.allow.common}|${wordcheck.allow.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	<property name="wordcheck.allow"	value="${wordcheck.allow.common}"/>
	
	<wordchecksuite dir="${wordcheck.src.dir}" output="${wordcheck.output}"
		excludes="browser/, calendar/, editor/, mail/, mobile/, suite/"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/browser" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.firefox}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/calendar" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.sunbird}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/editor" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.thunderbird}|${wordcheck.deny.seamonkey}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/mail" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.thunderbird}|${wordcheck.deny.seamonkey}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/mobile" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.fennec}"/>
	<wordchecksuite dir="${wordcheck.src.dir}/suite" output="${wordcheck.output}"
		allowpattern="${wordcheck.allow}" denypattern="${wordcheck.deny}|${wordcheck.deny.seamonkey}"/>
	
	<loadfile property="wordcheck.error" srcfile="${wordcheck.output}" encoding="UTF-8" failonerror="false"/>
	<fail message="${N}${wordcheck.error}${vmsg.wordcheck.found}" if="wordcheck.error"/>
</target>
<target name="suspectedwordcheck" depends="load-conf" unless="nosuspectedwordcheck" if="dosuspectedwordcheck">
	<delete file="${wordcheck.suspected.output}" failonerror="false"/>
	
	<equals property="wordcheck.suspected"	value="@{2}|${wordcheck.suspected.ja}" arg1="${locale}" arg2="ja"/>
	<equals property="wordcheck.suspected"	value="@{2}|${wordcheck.suspected.ja-JP-mac}" arg1="${locale}" arg2="ja-JP-mac"/>
	
	<wordchecksuite dir="${wordcheck.src.dir}" output="${wordcheck.suspected.output}"
		allowpattern="##NOTHING##" denypattern="${wordcheck.suspected}"/>
</target>

<!-- currently off by default -->
<target name="charcheck" depends="load-conf" unless="nocharcheck" if="docharcheck">
	<delete file="${charcheck.output}" failonerror="false"/>
	
	<fail message="${cmsg.noprop.charcheck.src.dir}" unless="charcheck.src.dir"/>
	<loadmessage pattern="^vmsg\.charcheck\."/>
	<fail message="${vmsg.charcheck.no.srcdir}">
		<condition><not><available file="${charcheck.src.dir}" type="dir"/></not></condition>
	</fail>
	
	<wordchecksuite dir="${charcheck.src.dir}" output="${charcheck.output}"
		allowpattern="${charcheck.allow}" denypattern="${charcheck.deny}" replacement="${charcheck.deny.replace}"/>
	
	<loadfile property="charcheck.error" srcfile="${charcheck.output}" encoding="UTF-8" failonerror="false"/>
	<fail message="${N}${charcheck.error}${vmsg.charcheck.found}" if="charcheck.error"/>
</target>

<target name="errorcheck" depends="syntaxcheck, placeholdercheck, pluralcheck, wordcheck, suspectedwordcheck, charcheck"/>



<!-- * escape and unescape * -->
<!-- switching unicode escape from/to utf-8 (only *.properties files are escaped/unescaped and others are just copied by default) -->
<target name="-escape-jar-" depends="load-mainconf" if="escape.jar.file">
	<property name="escape.jar.dir" value="${escape.todir}"/>
	<zip taskname="JAR Packaging (${escape.jar.file})" destfile="${escape.jar.dir}/${escape.jar.file}" compress="false" update="false">
		<zipfileset dir="${escape.todir}/" excludes="${escape.jar.file}"/>
	</zip>
</target>
<target name="escape" depends="load-mainconf"
	description="escape *.properties files and copy other files">
	<loadmessage pattern="^vmsg\.escape\."/>
	<fail message="${vmsg.escape.no.fromdir}">
		<condition><not><available file="${escape.fromdir}" type="dir"/></not></condition>
	</fail>
	<escapeunicode-copy fromdir="${escape.fromdir}" todir="${escape.todir}" encoding="${escape.encoding}"
		includes="${escape.includes}" excludes="${escape.excludes}"
		escapeincludes="${escape.escapeincludes}" escapeexcludes="${escape.escapeexcludes}"/>
	<antcall target="-escape-jar-"/>
</target>

<target name="-unescape-jar-" depends="load-mainconf" if="unescape.jar.file">
	<unjar src="${unescape.jar.file}"
		dest="${unescape.fromdir}"/>
</target>
<target name="unescape" depends="load-mainconf, -unescape-jar-"
	description="unescape *.properties files and copy other files">
	<loadmessage pattern="^vmsg\.unescape\."/>
	<fail message="${vmsg.unescape.no.fromdir}">
		<condition><not><available file="${unescape.fromdir}" type="dir"/></not></condition>
	</fail>
	<unescapeunicode-copy fromdir="${unescape.fromdir}" todir="${unescape.todir}" encoding="${unescape.encoding}"
		includes="${unescape.includes}" excludes="${unescape.excludes}"
		unescapeincludes="${unescape.unescapeincludes}" unescapeexcludes="${unescape.unescapeexcludes}"/>
</target>



<!-- * en-US to l10n * -->
<target name="prepare-hg">
	<!-- prepare properties to make this script possible to use stand alone -->
	<property name="lot.temp.dir" value="temp"/>
	<property name="locale" value="ja"/>
	<property name="hg.mozilla.dir" value="comm-central/mozilla"/>
	<property name="hg.comm.dir" value="comm-central"/>
	<property name="hg.mobile.dir" value="mobile-browser"/>
</target>

<target name="mozilla-to-l10n" depends="prepare-hg"
	description="copy changing directory structure of en-US locale files within mozilla repository">
	<!-- prepare properties to make this script possible to use stand alone -->
	<property name="mozilla-to-l10n.temp.dir" value="${lot.temp.dir}/mozilla-to-l10n"/>
	<property name="mozilla-to-l10n.dir" value="${lot.l10n.dir}/en-US"/>
	
	<!-- cleaning -->
	<delete dir="${mozilla-to-l10n.temp.dir}"/>
	
	<!-- now, copy changing directory structure -->
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/browser"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/browser/locales/en-US"/>
	</copy><!-- only firefox -->
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/dom"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/dom/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/inspector/chrome"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/inspector/resources/locale/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/irc"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/irc/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/spellcheck"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/spellcheck/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/reporter"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/reporter/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/extensions/venkman"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/extensions/venkman/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/netwerk"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/netwerk/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/other-licenses/branding/firefox"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/other-licenses/branding/firefox/locales/en-US"/>
	</copy><!-- only firefox -->
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/security/manager"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/security/manager/locales/en-US"/>
	</copy>
	<copy todir="${mozilla-to-l10n.temp.dir}/en-US/toolkit"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mozilla.dir}/toolkit/locales/en-US"/>
	</copy>
	
	<mkdir dir="${mozilla-to-l10n.dir}"/>
	<move todir="${mozilla-to-l10n.dir}">
		<fileset dir="${mozilla-to-l10n.temp.dir}/en-US"/>
	</move>
</target>

<target name="comm-to-l10n" depends="prepare-hg"
	description="copy changing directory structure of en-US locale files within comm repository">
	<!-- prepare properties to make this script possible to use stand alone -->
	<property name="comm-to-l10n.temp.dir" value="${lot.temp.dir}/comm-to-l10n"/>
	<property name="comm-to-l10n.dir" value="${lot.l10n.dir}/en-US"/>
	
	<!-- cleaning -->
	<delete dir="${comm-to-l10n.temp.dir}"/>
	
	<!-- now, copy changing directory structure -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/calendar"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/calendar/locales/en-US"/>
	</copy><!-- only sunbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/editor/ui"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/editor/ui/locales/en-US"/>
	</copy><!-- only thunderbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/mail"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/mail/locales/en-US"/>
	</copy><!-- only thunderbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/other-licenses/branding/sunbird"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/other-licenses/branding/sunbird/locales/en-US"/>
	</copy><!-- only sunbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/other-licenses/branding/thunderbird"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/other-licenses/branding/thunderbird/locales/en-US"/>
	</copy><!-- only thunderbird -->
	<copy todir="${comm-to-l10n.temp.dir}/en-US/suite"
		failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.comm.dir}/suite/locales/en-US"/>
	</copy><!-- only seamonkey -->
	
	<mkdir dir="${comm-to-l10n.dir}"/>
	<move todir="${comm-to-l10n.dir}">
		<fileset dir="${comm-to-l10n.temp.dir}/en-US"/>
	</move>
</target>

<target name="mobile-to-l10n" depends="prepare-hg"
	description="copy changing directory structure of en-US locale files within mobile-browser">
	<property name="mobile-to-l10n.dir" value="${lot.l10n.dir}/en-US"/>
	<mkdir dir="${mobile-to-l10n.dir}/mobile"/>
	<copy todir="${mobile-to-l10n.dir}/mobile" failonerror="false" preservelastmodified="true">
		<fileset dir="${hg.mobile.dir}/locales/en-US"/>
	</copy>
</target>

<target name="en-US-to-l10n" depends="mozilla-to-l10n, comm-to-l10n, mobile-to-l10n"
       description="copy changing directory structure of en-US locale files within both mozilla and comm repository"/>



<!-- * better to have * -->
<target name="imedic"
	description="generate IME dictionary for filters">
	<!-- 例えば "ウィンドウ" で "@@Window@@" に変換するための辞書を生成 -->
	<fail message="not implemented yet..."/>
</target>


</project>
